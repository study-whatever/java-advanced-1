# 멀티태스킹과 멀티프로세싱
## 단일 프로그램 실행
CPU가 1개만 있을 때, 프로그램 2개 이상을 동시에 실행한다

프로그램의 실행 = 프로그램을 구성하는 코드를 순서대로 CPU에서 실행하는 일
가정: 한 번에 하나의 프로그램만 실행한다

만약 하나의 프로그램에 있는 코드를 모두 실행한 후에 다른 프로그램을 실행할 수 있다면? 매우 답답하다
해결: **멀티 태스킹** = 하나의 CPU 코어로 여러 프로그램을 동시에 실행한다

## 멀티태스킹
애니메이션처럼..
CPU는 초당 수식업 번 이상의 연산을 수행
-> 매우 빠르게 두 프로그램의 코드를 번갈아 수행한다
사람이 느낄 때는 두 프로그램이 동시에 실행되는 것처럼 느낀다 (대략 0.01초 단위로)
![Pasted image 20250126221922.png](image%2FPasted%20image%2020250126221922.png)

**시분할**(Time Sharing): 각 프로그램의 실행 시간을 분할해서 마치 동시에 실행되는 것처럼 하는 기법

## 멀티프로세싱
CPU 코어가 둘 이상인 경우: 물리적으로 동시에 2개의 프로그램을 처리할 수 있다
이때도 2개보다 더 많은 프로그램을 실행할 수 있다
> **멀티프로세싱**: 둘 이상의 프로세서(CPU 코어)를 사용해서 여러 작업을 동시에 처리하는 기술

### 멀티프로세싱 vs 멀티태스킹
- 멀티프로세싱
    - 하드웨어 장비의 관점
    - 여러 CPU를 사용해서 동시에 여러 작업을 수행
    - 하드웨어 기반으로 성능 향상
- 멀티태스킹
    - 운영체제 소프트웨어의 관점
    - 단일 CPU가 여러 작업을 동시에 수행하는 것처럼 보이게 하는 것
    - 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당

# 프로세스와 스레드
![Pasted image 20250126222811.png](image%2FPasted%20image%2020250126222811.png)
## 프로세스
- 프로세스: 운영체제 안에서 실행중인 프로그램
    - 실행 중인 프로그램의 인스턴스
- 독립적인 메모리 공간을 갖고 있다 -> 서로 간섭하지 않는다
- 서로의 메모리에 직접 접근할 수 없다
- 하나의 프로세스에 문제가 생겨도 다른 프로세스는 영향이 없음

**프로세스의 메모리 구성**
- 코드 섹션: 실행할 프로그램의 코드가 저장
- 데이터 섹션: 전역 변수, 정적 변수가 저장
- 힙: 동적으로 할당되는 메모리 영역
- 스택: 메서드 호출 시 생성되는 지역 변수와 반환 주소가 저장

## 스레드
**프로세스는 하나 이상의 스레드를 반드시 포함한다**
- 스레드: 프로세스 내에서 실행되는 작업의 단위
- 프로세스가 제공하는 동일한 메모리 공간을 공유
- 프로세스보다 단순해서 생성, 관리가 쉽고 가볍다
  **메모리 구성**
- 공유 메모리: 같은 프로세스의 코드 섹션, 데이터 섹션, 힙 메모리
- 개별 스택: 개별 스레드가 가지고 있는 스택

**프로그램의 실행**
프로세스 안에 있는 코드가 한 줄식 실행되는 것
스레드: 프로세스의 코드를 실행하는 흐름 -> 실제 실행하는 건 스레드다!

- 단일 스레드: 한 프로세스 내에 하나의 스레드만
- 멀티 스레드: 한 프로세스 내에 여러 스레드가 존재

**멀티 스레드가 필요한 이유**
- 하나의 프로그램도 그 안에서 동시에 여러 작업이 필요하다

# 스레드와 스케줄링
## 단일 코어 스케줄링
운영체제 내부에 스케줄링 큐를 가지고 있음

큐에서 꺼내서 실행, 일정 시간이 지나면 다시 큐에 넣는다

## 멀티 코어 스케줄링
코어가 2개 이상이면 한 번에 많은 스레드를 동시에 실행한다

## 정리
- 멀티태스킹: 동시에 여러 작업을 수행, 운영체제가 이를 위해 스케줄링 기법 수행
- 스케줄링: CPU 시간을 여러 작업에 나누어 분배
- 프로세스: 실행 중인 프로그램의 인스턴스
- 스레드: 프로세스 내에서 실행되는 작은 단위, 실제 CPU에 의해 실행되는 단위

- 프로세스의 역할: 실행 환경 제공, 프로세스가 스레드의 컨테이너 역할을 한다

# 컨텍스트 스위칭
멀티태스킹이 반드시 효율적인 것만은 아니다

운영체제가 멀티태스킹을 수행할 때, 각 스레드가 실행되었던 위치, 변수 값들을 CPU에 불러들여야 한다

**컨텍스트 스위칭**
- 컨텍스트: 현재 작업하는 문맥
- 이전에 실행 중인 값을 메모리에 저장, 이후에 다시 실행하는 시점에 저장하는 값들을 다시 불러온다
- 비용이 발생!

-> 멀티스레드는 대부분 효율적이지만, 컨텍스트 스위칭 과정이 필요해서 항상 효율적인 것은 아니다

**CPU Bound vs I/O Bound**
- CPU-바운드 작업
    - CPU의 연산 능력을 많이 요구하는 작업
    - 계산, 데이터 처리, 알고리즘 실행 등
    - 예: 수학 연산, 데이터 분석, 비디오 인코딩
- I/O-바운드 작업
    - 디스크, 네트워크, 파일 시스템과 같은 입출력 작업을 많이 요구하는 작업
    - CPU는 상대적으로 대기 상태에 있는 경우가 많다 -> 스레드가 CPU를 사용하지 않고 I/O 작업이 완료될 때까지 대기
    - 예: 데이터베이스 쿼리, 파일 읽기/쓰기, 네트워크 통신, 사용자 입력 처리 등

**웹 애플리케이션 서버**
실무에서는 보통 I/O 바운드 작업이 많다
요청이 많아도 CPU는 많이 사용되지 않는다 -> 스레드의 개수를 늘려야 함

-> I/O 바운드 작업은 CPU 코어 수보다 많은 스레드를 생성한다, 테스트를 통해..

